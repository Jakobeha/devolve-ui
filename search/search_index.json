{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"devolve-ui: super simple reactive graphics for browser and terminal Disclaimer: this is an early project. It's subject to change and have bugs Live demo | Clone to get started devolve-ui is a super simple graphics library for canvas-based websites (games) and TUIs. A single devolve-ui app can be embedded in a website and run on the command line via node . devolve-ui is JSX-based like React, but renders to canvas or terminal instead of DOM. It should not be used for traditional web pages. Example: // https://github.com/Jakobeha/devolve-ui-demos/src/readme.tsx import { DevolveUI, useState, useInterval } from '@raycenity/devolve-ui' const App = ({ name }) => { const [counter, setCounter] = useState(0) useInterval(1000, () => { setCounter(counter + 1) }) return ( <zbox width='100%'> <vbox x={2} y={2} gap={1}> <zbox width='100%'> <hbox width='100%'> <text color='white'>Hello {name}</text> <text color='white' x='100%' anchorX={1}>{counter} seconds</text> </hbox> <color color='orange' /> </zbox> <source src='dog.png' width='100%' /> </vbox> <border style='single' color='orange' width='prev + 4' height='prev + 4'/> </zbox> ) } new DevolveUI(App, { name: 'devolve-ui' }).show() // Works in node or browser (with additional pixi.js script) Important setup information: if adding to an existing project, besides installing, you must add this to your tsconfig.json for JSX support: { /* ... */ \"jsx\": \"preserve\", /** if using esbuild, otherwise \"react\" */ \"jsxImportSource\": \"@raycenity/devolve-ui\" } Pro tip: If you debug TUIs in IntelliJ, you can see console outputs in a separate tab from the terminal output! Installing (with pnpm) # if you don't have pnpm installed, uncomment the next line # curl -fsSL https://get.pnpm.io/install.sh | sh - pnpm add @raycenity/devolve-ui Repository info devolve-ui is built using esbuild . The package manager used is pnpm . Linting is done by standard , however we use a slightly modified version removing some warnings ( ts-standardx.mjs ). Docs are generated by mkdocs . Feel free to submit issues / pull requests on the Github . Features Cross-platform devolve-ui is cross-platform (isomorphic): a devolve-ui application may run in both web browsers and terminals (via node.js). When the application is run in the terminal, graphics are much simpler and certain effects and animations are removed, hence the name \"devolve\"-ui. When a devolve-ui application is run in the web browser, it uses pixi.js for rendering. Super simple devolve-ui uses JSX and React-style components : you write your UI declaratively and use hooks (useState, useEffect, useLazy, useInput) for local state and side-effects. Your UI is literally a function which takes the global state, and returns a render of your application. Unlike React, the nodes (lowercase components) which devolve-ui uses are not HTML elements, they are: hbox , vbox , zbox : Layout child components hbox : Places children horizontally vbox : Places children vertically zbox : Places children on top of each other (no position offsets) text : Contains text solid : Renders a solid color border : Renders a border source : Renders an image, video, or other external graphic (WIP unstable) pixi : Can only be created via PixiComponent . These contain custom pixi components in the browser, and are invisible in TUIs. Another notable difference is the layout system. devolve-ui does not use CSS, instead all node bounds are calculated using only the parent and previous child. As a result, you must specify bounds much more explicitly. See Bounds for more. Prompt-based GUI Prompt-based GUI is a new-ish paradigm where your application interfaces with the UI via prompts . devolve-ui has built-in support for prompt-based GUI via the PromptDevolveUI class. Read this article for more. Implementation Source Directory overview core : The main code of devolve-ui core/hooks : Built-in hooks core/vdom : The \"DOM\" in devolve-ui: nodes, attributes, and JSX. renderer : Platform-specific rendering prompt : Prompt-based GUI helpers. Notable types VNode : Virtual \"DOM\" node, e.g. box , text , color VComponent : Synchronizes a component function to a persistent VNode and preserves state from hooks. Bounds : A node's bounds depend on the parent and previous component: therefore Bounds are literally a function from parent and previous component properties to a BoundingBox . See src/core/vdom/bounds.ts","title":"Home"},{"location":"#devolve-ui-super-simple-reactive-graphics-for-browser-and-terminal","text":"Disclaimer: this is an early project. It's subject to change and have bugs Live demo | Clone to get started devolve-ui is a super simple graphics library for canvas-based websites (games) and TUIs. A single devolve-ui app can be embedded in a website and run on the command line via node . devolve-ui is JSX-based like React, but renders to canvas or terminal instead of DOM. It should not be used for traditional web pages. Example: // https://github.com/Jakobeha/devolve-ui-demos/src/readme.tsx import { DevolveUI, useState, useInterval } from '@raycenity/devolve-ui' const App = ({ name }) => { const [counter, setCounter] = useState(0) useInterval(1000, () => { setCounter(counter + 1) }) return ( <zbox width='100%'> <vbox x={2} y={2} gap={1}> <zbox width='100%'> <hbox width='100%'> <text color='white'>Hello {name}</text> <text color='white' x='100%' anchorX={1}>{counter} seconds</text> </hbox> <color color='orange' /> </zbox> <source src='dog.png' width='100%' /> </vbox> <border style='single' color='orange' width='prev + 4' height='prev + 4'/> </zbox> ) } new DevolveUI(App, { name: 'devolve-ui' }).show() // Works in node or browser (with additional pixi.js script) Important setup information: if adding to an existing project, besides installing, you must add this to your tsconfig.json for JSX support: { /* ... */ \"jsx\": \"preserve\", /** if using esbuild, otherwise \"react\" */ \"jsxImportSource\": \"@raycenity/devolve-ui\" } Pro tip: If you debug TUIs in IntelliJ, you can see console outputs in a separate tab from the terminal output!","title":"devolve-ui: super simple reactive graphics for browser and terminal"},{"location":"#installing-with-pnpm","text":"# if you don't have pnpm installed, uncomment the next line # curl -fsSL https://get.pnpm.io/install.sh | sh - pnpm add @raycenity/devolve-ui","title":"Installing (with pnpm)"},{"location":"#repository-info","text":"devolve-ui is built using esbuild . The package manager used is pnpm . Linting is done by standard , however we use a slightly modified version removing some warnings ( ts-standardx.mjs ). Docs are generated by mkdocs . Feel free to submit issues / pull requests on the Github .","title":"Repository info"},{"location":"#features","text":"","title":"Features"},{"location":"#cross-platform","text":"devolve-ui is cross-platform (isomorphic): a devolve-ui application may run in both web browsers and terminals (via node.js). When the application is run in the terminal, graphics are much simpler and certain effects and animations are removed, hence the name \"devolve\"-ui. When a devolve-ui application is run in the web browser, it uses pixi.js for rendering.","title":"Cross-platform"},{"location":"#super-simple","text":"devolve-ui uses JSX and React-style components : you write your UI declaratively and use hooks (useState, useEffect, useLazy, useInput) for local state and side-effects. Your UI is literally a function which takes the global state, and returns a render of your application. Unlike React, the nodes (lowercase components) which devolve-ui uses are not HTML elements, they are: hbox , vbox , zbox : Layout child components hbox : Places children horizontally vbox : Places children vertically zbox : Places children on top of each other (no position offsets) text : Contains text solid : Renders a solid color border : Renders a border source : Renders an image, video, or other external graphic (WIP unstable) pixi : Can only be created via PixiComponent . These contain custom pixi components in the browser, and are invisible in TUIs. Another notable difference is the layout system. devolve-ui does not use CSS, instead all node bounds are calculated using only the parent and previous child. As a result, you must specify bounds much more explicitly. See Bounds for more.","title":"Super simple"},{"location":"#prompt-based-gui","text":"Prompt-based GUI is a new-ish paradigm where your application interfaces with the UI via prompts . devolve-ui has built-in support for prompt-based GUI via the PromptDevolveUI class. Read this article for more.","title":"Prompt-based GUI"},{"location":"#implementation","text":"Source","title":"Implementation"},{"location":"#directory-overview","text":"core : The main code of devolve-ui core/hooks : Built-in hooks core/vdom : The \"DOM\" in devolve-ui: nodes, attributes, and JSX. renderer : Platform-specific rendering prompt : Prompt-based GUI helpers.","title":"Directory overview"},{"location":"#notable-types","text":"VNode : Virtual \"DOM\" node, e.g. box , text , color VComponent : Synchronizes a component function to a persistent VNode and preserves state from hooks. Bounds : A node's bounds depend on the parent and previous component: therefore Bounds are literally a function from parent and previous component properties to a BoundingBox . See src/core/vdom/bounds.ts","title":"Notable types"},{"location":"design-decisions/","text":"Design decisions devolve-ui is a very new and unstable library so it's API and design decisions are subject to change. Please be aware of this if you intend to use devolve-ui in production-grade software. Simple and extensible devolve-ui is designed to be simple and extensible. We generally don't provide functionality if it introduces unnecessary complexity. Nearly all abstractions are leaky, so not only is the API simple, so is the implementation. When adding a feature, either a) add it so that it doesn't interfere with existing features and code, or b) make a small change to the core library making it more extensible ideally not affecting the API , and then do a. Furthermore, if any one feature becomes too large, especially if it significantly impacts size or performance, move it into a separate package. Encourage good design and discourage confusing bugs Make it easy to add new small components. Also automatically useDynamicFn in hooks to avoid the React Stale Closure Problem as much as possible. Isomorphic, easy to use Configuring node.js packages and avoid confusing JavaScript transpile errors is honestly very difficult. devolve-ui is isomorphic, is an es module, and should be as easy to use as possible. We provide examples so you can literally clone the repository, remove the example code, and already you have all the boilerplate ready and can start building your site or CLI app.","title":"Design decisions"},{"location":"design-decisions/#design-decisions","text":"devolve-ui is a very new and unstable library so it's API and design decisions are subject to change. Please be aware of this if you intend to use devolve-ui in production-grade software.","title":"Design decisions"},{"location":"design-decisions/#simple-and-extensible","text":"devolve-ui is designed to be simple and extensible. We generally don't provide functionality if it introduces unnecessary complexity. Nearly all abstractions are leaky, so not only is the API simple, so is the implementation. When adding a feature, either a) add it so that it doesn't interfere with existing features and code, or b) make a small change to the core library making it more extensible ideally not affecting the API , and then do a. Furthermore, if any one feature becomes too large, especially if it significantly impacts size or performance, move it into a separate package.","title":"Simple and extensible"},{"location":"design-decisions/#encourage-good-design-and-discourage-confusing-bugs","text":"Make it easy to add new small components. Also automatically useDynamicFn in hooks to avoid the React Stale Closure Problem as much as possible.","title":"Encourage good design and discourage confusing bugs"},{"location":"design-decisions/#isomorphic-easy-to-use","text":"Configuring node.js packages and avoid confusing JavaScript transpile errors is honestly very difficult. devolve-ui is isomorphic, is an es module, and should be as easy to use as possible. We provide examples so you can literally clone the repository, remove the example code, and already you have all the boilerplate ready and can start building your site or CLI app.","title":"Isomorphic, easy to use"},{"location":"prompt-based-gui/","text":"Prompt-based GUI: how to define a GUI as a function In GUI-based applications users are often presented with prompts , like dialog boxes. The user must click \"ok\" or \"cancel\" in order to continue. However, \"prompt\" can be generalized into more UI elements. A form is a prompt, where a user must fill out the fields and click \"submit\". A menu is a prompt, where a user must click one of the menu items. We define \"prompt\" as \" a series of interactions a user must complete in order for something to occur \". Going to the extreme, any GUI element can be represented a prompt, and any application can be considered a concurrent set of prompts. But why is this important? Because a \"prompt\" can be represented as an asynchronous function. In turn, we can leverage the power of functional programming and general function composition when writing GUIs, and even define entire GUI-based applications as functions . If you're a fan of functional programming, this may be significant. -- Henceforth we refer to a function which presents a \"prompt\", as defined above, as a prompt-function . GUI implemented as a function TODO example Here is a simple social media site represented as a function in Haskell, a functional programming language, using prompt-based GUI. TODO example When to use prompt-based GUI In practice, you shouldn't necessarily implement every GUI as a prompt-function. But prompt-functions have some benefits over \"traditional\" (e.g. React-Redux) components. Ideally, you will implement \"prompt-like\" UI, like dialog boxes, as prompt-functions, and continuous UI, like menus and the main screen, as standard components. Automation Prompt-functions are especially better if you want your application to be easily automated. Automating a prompt-function is as simple as replacing the function implementation with a calls to your automator, be it a neural network or remote client or sequence of GUI actions recorded into a text file. Automating a component-based application, especially if it listens for complex mouse or touch gestures, is harder. GUI as a state machine Prompt-functions are also better at handling state transitions. If you model your application as a state or activity diagram, it's much easier and more straightforward to convert that diagram into a prompt-function than a component. In the component, you need a property to represent the current location in the diagram; in a prompt-function, the location is automatic because it's simply the location inside the function's code.","title":"Prompt-based GUI: how to define a GUI as a function"},{"location":"prompt-based-gui/#prompt-based-gui-how-to-define-a-gui-as-a-function","text":"In GUI-based applications users are often presented with prompts , like dialog boxes. The user must click \"ok\" or \"cancel\" in order to continue. However, \"prompt\" can be generalized into more UI elements. A form is a prompt, where a user must fill out the fields and click \"submit\". A menu is a prompt, where a user must click one of the menu items. We define \"prompt\" as \" a series of interactions a user must complete in order for something to occur \". Going to the extreme, any GUI element can be represented a prompt, and any application can be considered a concurrent set of prompts. But why is this important? Because a \"prompt\" can be represented as an asynchronous function. In turn, we can leverage the power of functional programming and general function composition when writing GUIs, and even define entire GUI-based applications as functions . If you're a fan of functional programming, this may be significant. -- Henceforth we refer to a function which presents a \"prompt\", as defined above, as a prompt-function .","title":"Prompt-based GUI: how to define a GUI as a function"},{"location":"prompt-based-gui/#gui-implemented-as-a-function","text":"TODO example Here is a simple social media site represented as a function in Haskell, a functional programming language, using prompt-based GUI. TODO example","title":"GUI implemented as a function"},{"location":"prompt-based-gui/#when-to-use-prompt-based-gui","text":"In practice, you shouldn't necessarily implement every GUI as a prompt-function. But prompt-functions have some benefits over \"traditional\" (e.g. React-Redux) components. Ideally, you will implement \"prompt-like\" UI, like dialog boxes, as prompt-functions, and continuous UI, like menus and the main screen, as standard components.","title":"When to use prompt-based GUI"},{"location":"prompt-based-gui/#automation","text":"Prompt-functions are especially better if you want your application to be easily automated. Automating a prompt-function is as simple as replacing the function implementation with a calls to your automator, be it a neural network or remote client or sequence of GUI actions recorded into a text file. Automating a component-based application, especially if it listens for complex mouse or touch gestures, is harder.","title":"Automation"},{"location":"prompt-based-gui/#gui-as-a-state-machine","text":"Prompt-functions are also better at handling state transitions. If you model your application as a state or activity diagram, it's much easier and more straightforward to convert that diagram into a prompt-function than a component. In the component, you need a property to represent the current location in the diagram; in a prompt-function, the location is automatic because it's simply the location inside the function's code.","title":"GUI as a state machine"}]}